#pragma once

#include <common/inttypes.hpp>
#include <common/utils.hpp>
#include <mutex>
#include <memory/Memory.hpp>
#include <lib/Status.hpp>

template<typename T> class unique_ptr {
private:
    T *internalPointer;

public:
    unique_ptr(T *rawPointer = nullptr):
        internalPointer{rawPointer} {}
    unique_ptr(unique_ptr &other) = delete;
    unique_ptr(unique_ptr &&other) {
        internalPointer = other.internalPointer;
        other.internalPointer = nullptr;
    }
    void operator=(unique_ptr &other) = delete;
    void operator=(unique_ptr &&other) {
        if (internalPointer) {
            delete internalPointer;
        }
        internalPointer = other.internalPointer;
        other.internalPointer = nullptr;
    }
    ~unique_ptr() {
        if (internalPointer) {
            delete internalPointer;
        }
    }

    operator bool() {
        return internalPointer;
    }
    T *operator->() {
        assert(*this);
        return internalPointer;
    }
    bool operator==(unique_ptr &) = delete;
};


template<typename T> class weak_ptr;

template<typename T> class shared_ptr {
protected:
    friend class weak_ptr<T>;
    struct InternalPointer {
        mutex lock;
        size_t referenceCount{1};
        size_t weakReferenceCount{0};
        bool valid{true};
        T *const rawPointer;

        InternalPointer(T *rawPointer):
            rawPointer{rawPointer} {}
        ~InternalPointer() {
            if (rawPointer) {
                delete rawPointer;
            }
        }
    };

    InternalPointer *internalPointer{nullptr};

    void checkReferenceCounts(bool &shouldDelete) {
        if (internalPointer->referenceCount == 0) {
            if (internalPointer->weakReferenceCount == 0) {
                shouldDelete = true;
            } else {
                delete internalPointer->rawPointer;
                internalPointer->valid = false;
            }
        }
        internalPointer = nullptr;
    }

public:
    shared_ptr() {}
    explicit shared_ptr(T *rawPointer) {
        internalPointer = new InternalPointer(rawPointer);
        assert(internalPointer);
    }
    shared_ptr(const shared_ptr &other) {
        if (other.internalPointer) {
            scoped_lock lg(other.internalPointer->lock);
            internalPointer = other.internalPointer;
            internalPointer->referenceCount++;
        } else {
            internalPointer = nullptr;
        }
    }
    shared_ptr(shared_ptr &&other) {
        internalPointer = other.internalPointer;
        other.internalPointer = nullptr;
    }
    void operator=(const shared_ptr &other) {
        reset();
        if (other.internalPointer) {
            scoped_lock lg(other.internalPointer->lock);
            internalPointer = other.internalPointer;
            internalPointer->referenceCount++;
        }
    }
    void operator=(shared_ptr &&other) {
        reset();
        if (other.internalPointer) {
            scoped_lock lg(other.internalPointer->lock);
            internalPointer = other.internalPointer;
            other.internalPointer = nullptr;
        }
    }

    operator bool() const {
        return internalPointer && internalPointer->valid && internalPointer->rawPointer;
    }
    T *operator->() const {
        assert(*this);
        return internalPointer->rawPointer;
    }
    T *get() const {
        assert(internalPointer);
        return internalPointer->rawPointer;
    }
    T& operator *() const {
        assert(*this);
        return *internalPointer->rawPointer;
    }
    void reset() {
        bool shouldDelete{false};
        if (internalPointer) {
            scoped_lock lg(internalPointer->lock);
            assert(internalPointer->referenceCount > 0);
            internalPointer->referenceCount--;
            checkReferenceCounts(shouldDelete);
        }
        if (shouldDelete) {
            delete internalPointer;
        }
    }
    void reset(T *newPointer) {
        reset();
        internalPointer = new InternalPointer(newPointer);
    }
    bool operator==(const shared_ptr &other) {
        return internalPointer == other.internalPointer;
    }
};

template<typename T> class weak_ptr {
private:
    typename shared_ptr<T>::InternalPointer *internalPointer{nullptr};

public:
    weak_ptr() {}
    weak_ptr(const shared_ptr<T> &sharedPointer) {
        assert(sharedPointer.internalPointer);
        scoped_lock lg(sharedPointer.internalPointer->lock);
        internalPointer = sharedPointer.internalPointer;
        internalPointer->weakReferenceCount++;
    }
    weak_ptr(const weak_ptr &other) {
        if (other.internalPointer) {
            scoped_lock lg(other.internalPointer->lock);
            internalPointer = other.internalPointer;
            internalPointer->weakReferenceCount++;
        } else {
            internalPointer = nullptr;
        }
    }
    weak_ptr(T &&other) {
        internalPointer = other.internalPointer;
        other.internalPointer = nullptr;
    }
    void operator=(const weak_ptr &other) {
        reset();
        if (other.internalPointer) {
            scoped_lock lg(other.internalPointer->lock);
            internalPointer = other.internalPointer;
            internalPointer->weakReferenceCount++;
        }
    }

    void reset() {
        bool shouldDelete{false};
        if (internalPointer) {
            scoped_lock lg(internalPointer->lock);
            internalPointer->weakReferenceCount--;
            if (internalPointer->referenceCount == 0 && internalPointer->weakReferenceCount == 0) {
                shouldDelete = true;
            }
            internalPointer = nullptr;
        }
        if (shouldDelete) {
            delete internalPointer;
        }
    }
    shared_ptr<T> lock() {
        if (internalPointer) {
            shared_ptr<T> result;
            scoped_lock lg(internalPointer->lock);
            if (internalPointer->valid) {
                internalPointer->referenceCount++;
                result.internalPointer = internalPointer;
                return move(result);
            }
        }
        return {};
    }
    bool operator==(const weak_ptr &other) const {
        return internalPointer == other.internalPointer;
    }
    /* non-standard */
    bool empty() {
        return internalPointer == nullptr;
    }
};

template <typename T, typename ...ArgumentTypes>
Result<shared_ptr<T>> make_shared(ArgumentTypes &&...args) {
    Result<T *> raw = make_raw<T>(args...);
    if (raw) {
        return move(shared_ptr(*raw));
    } else {
        return raw.status();
    }
}

template <typename T, typename ...ArgumentTypes>
Result<unique_ptr<T>> make_unique(ArgumentTypes &&...args) {
    Result<T *> raw = make_raw<T>(args...);
    if (raw) {
        return move(unique_ptr(*raw));
    } else {
        return raw.status();
    }
}

template <typename T, typename ...ArgumentTypes>
Result<T *> make_raw(ArgumentTypes &&...args) {
    Result<KernelVirtualAddress> address = Memory::instance()->allocateVirtualArea(sizeof(T), alignof(T));
    if (!address) {
        return address.status();
    }

    Status status = Status::OK();
    /* placement new to run constructor */
    T *pointer = new (*address) T(args..., status);
    if (!status) {
        delete pointer;
        return status;
    }
    return pointer;
}

template <typename T>
Result<T *> make_raw_array(size_t count) {
    Result<KernelVirtualAddress> address = Memory::instance()->allocateVirtualArea(sizeof(T) * count, alignof(T));
    if (!address) {
        return address.status();
    }

    for (size_t index = 0; index < count; index++) {
        /* placement new to run constructor */
        new (address + sizeof(T) * index) T;
    }
    return address->asPointer<T>();
}
