#pragma once

#include <common/inttypes.hpp>
#include <common/utils.hpp>
#include <mutex>
#include <memory/DLMallocGlue.hpp>
#include <interrupts/KernelInterruptsLock.hpp>
#include <common/PlacementNew.hpp>

namespace std {
    enum class align_val_t: size_t {};
}

template<typename T> class unique_ptr {
private:
    T *internalPointer;

public:
    unique_ptr() noexcept :
        internalPointer{nullptr} {}
    unique_ptr(T *rawPointer) noexcept :
        internalPointer{rawPointer} {}
    unique_ptr(unique_ptr &other) = delete;
    unique_ptr(unique_ptr &&other) noexcept {
        internalPointer = other.internalPointer;
        other.internalPointer = nullptr;
    }
    void operator=(unique_ptr &other) = delete;
    void operator=(unique_ptr &&other) noexcept {
        if (internalPointer) {
            delete internalPointer;
        }
        internalPointer = other.internalPointer;
        other.internalPointer = nullptr;
    }
    ~unique_ptr() noexcept {
        if (internalPointer) {
            delete internalPointer;
        }
    }

    operator bool() const noexcept {
        return internalPointer;
    }
    T *operator->() noexcept {
        assert(*this);
        return internalPointer;
    }
    const T *operator->() const noexcept {
        assert(*this);
        return internalPointer;
    }
    bool operator==(unique_ptr &) = delete;
};


template<typename T> class weak_ptr;

template<typename T> class shared_ptr {
protected:
    friend class weak_ptr<T>;
    template<typename New, typename Original>
    friend shared_ptr<New> dynamic_pointer_cast(shared_ptr<Original> original);
    template<typename New, typename Original>
    friend weak_ptr<New> dynamic_pointer_cast(weak_ptr<Original> original);

    struct InternalPointer {
        SpinLock lock;
        size_t referenceCount{1};
        size_t weakReferenceCount{0};
        bool valid{true};
        T *const rawPointer;

        InternalPointer(T *rawPointer) noexcept :
            rawPointer{rawPointer} {}
        ~InternalPointer() noexcept;
        void checkReferenceCounts(bool &shouldDelete) noexcept;
    };

    InternalPointer *internalPointer{nullptr};


public:
    shared_ptr() noexcept {}
    explicit shared_ptr(T *rawPointer) {
        internalPointer = new InternalPointer(rawPointer);
        assert(internalPointer);
    }
    shared_ptr(const shared_ptr &other) noexcept {
        if (other.internalPointer) {
            scoped_lock lg1(KernelInterruptsLock);
            scoped_lock lg(other.internalPointer->lock);
            internalPointer = other.internalPointer;
            internalPointer->referenceCount++;
        } else {
            internalPointer = nullptr;
        }
    }
    shared_ptr(shared_ptr &&other) noexcept {
        internalPointer = other.internalPointer;
        other.internalPointer = nullptr;
    }
    ~shared_ptr() noexcept {
        reset();
    }
    void operator=(const shared_ptr &other) noexcept {
        reset();
        if (other.internalPointer) {
            scoped_lock lg1(KernelInterruptsLock);
            scoped_lock lg(other.internalPointer->lock);
            internalPointer = other.internalPointer;
            internalPointer->referenceCount++;
        }
    }
    void operator=(shared_ptr &&other) noexcept {
        reset();
        if (other.internalPointer) {
            scoped_lock lg1(KernelInterruptsLock);
            scoped_lock lg(other.internalPointer->lock);
            internalPointer = other.internalPointer;
            other.internalPointer = nullptr;
        }
    }

    operator bool() const noexcept {
        return internalPointer && internalPointer->valid && internalPointer->rawPointer;
    }
    T *operator->() const noexcept {
        assert(*this);
        return internalPointer->rawPointer;
    }
    T *get() const noexcept {
        assert(internalPointer);
        return internalPointer->rawPointer;
    }
    T& operator *() const noexcept {
        assert(*this);
        return *internalPointer->rawPointer;
    }
    void reset() noexcept {
        bool shouldDelete{false};
        if (internalPointer) {
            scoped_lock lg1(KernelInterruptsLock);
            scoped_lock lg(internalPointer->lock);
            assert(internalPointer->referenceCount > 0);
            internalPointer->referenceCount--;
            internalPointer->checkReferenceCounts(shouldDelete);
        }
        if (shouldDelete) {
            delete internalPointer;
        }
        internalPointer = nullptr;
    }
    void reset(T *newPointer) noexcept {
        reset();
        internalPointer = new InternalPointer(newPointer);
    }
    bool operator==(const shared_ptr &other) noexcept {
        return internalPointer == other.internalPointer;
    }
};

template<typename T> class weak_ptr {
private:
    template<typename New, typename Original>
    friend weak_ptr<New> dynamic_pointer_cast(weak_ptr<Original> original);

    typename shared_ptr<T>::InternalPointer *internalPointer{nullptr};

public:
    weak_ptr() noexcept {}
    weak_ptr(const shared_ptr<T> &sharedPointer) noexcept {
        assert(sharedPointer.internalPointer);
        scoped_lock lg1(KernelInterruptsLock);
        scoped_lock lg(sharedPointer.internalPointer->lock);
        internalPointer = sharedPointer.internalPointer;
        internalPointer->weakReferenceCount++;
    }
    weak_ptr(const weak_ptr &other) noexcept {
        if (other.internalPointer) {
            scoped_lock lg1(KernelInterruptsLock);
            scoped_lock lg(other.internalPointer->lock);
            internalPointer = other.internalPointer;
            internalPointer->weakReferenceCount++;
        } else {
            internalPointer = nullptr;
        }
    }
    weak_ptr(T &&other) noexcept {
        internalPointer = other.internalPointer;
        other.internalPointer = nullptr;
    }
    ~weak_ptr() noexcept {
        reset();
    }
    void operator=(const weak_ptr &other) noexcept {
        reset();
        if (other.internalPointer) {
            scoped_lock lg1(KernelInterruptsLock);
            scoped_lock lg(other.internalPointer->lock);
            internalPointer = other.internalPointer;
            internalPointer->weakReferenceCount++;
        }
    }

    void reset() noexcept {
        bool shouldDelete{false};
        if (internalPointer) {
            scoped_lock lg1(KernelInterruptsLock);
            scoped_lock lg(internalPointer->lock);
            internalPointer->weakReferenceCount--;
            internalPointer->checkReferenceCounts(shouldDelete);
        }
        if (shouldDelete) {
            delete internalPointer;
        }
        internalPointer = nullptr;
    }
    shared_ptr<T> lock() noexcept {
        if (internalPointer) {
            shared_ptr<T> result;
            scoped_lock lg1(KernelInterruptsLock);
            scoped_lock lg(internalPointer->lock);
            if (internalPointer->valid) {
                internalPointer->referenceCount++;
                result.internalPointer = internalPointer;
                return move(result);
            }
        }
        return {};
    }
    bool operator==(const weak_ptr &other) const noexcept {
        return internalPointer == other.internalPointer;
    }
};

template <typename T, typename ...ArgumentTypes>
shared_ptr<T> make_shared(ArgumentTypes &&...args) {
    return shared_ptr(new T(args...));
}

template <typename T, typename ...ArgumentTypes>
unique_ptr<T> make_unique(ArgumentTypes &&...args) {
    return unique_ptr(new T(args...));
}

template<typename New, typename Original>
shared_ptr<New> dynamic_pointer_cast(shared_ptr<Original> original) {
    if (!original.internalPointer || !dynamic_cast<New *>(original.get())) {
        return {};
    }
    shared_ptr<New> result;
    scoped_lock sl1(KernelInterruptsLock);
    scoped_lock sl(original.internalPointer->lock);
    result.internalPointer = original.internalPointer;
    result.internalPointer->referenceCount++;
    return result;
}

template<typename New, typename Original>
weak_ptr<New> dynamic_pointer_cast(weak_ptr<Original> originalWeak) {
    shared_ptr<Original> original = originalWeak.lock();
    if (!original.internalPointer || !dynamic_cast<New *>(original.get())) {
        return {};
    }
    weak_ptr<New> result;
    scoped_lock sl1(KernelInterruptsLock);
    scoped_lock sl(original.internalPointer->lock);
    result.internalPointer = original.internalPointer;
    result.internalPointer->weakReferenceCount++;
    return result;
}
