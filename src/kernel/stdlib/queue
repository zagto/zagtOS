#pragma once

#include <vector>

template<typename T>
class queue {
private:
    vector<T> buffer;
    size_t firstIndex{0};

public:
    queue() noexcept {};
    queue(queue &other) = delete;
    queue(queue &&other) :
        buffer{move(other.buffer)},
        firstIndex{other.firstIndex} {
        other.firstIndex = 0;
    }

    /* not implemented for now, but there is nothing wrong with copying queues
     * implement this if you need it */
    void operator=(queue &) = delete;
    void operator=(queue &&other) {
        buffer = move(other.buffer);
        firstIndex = other.firstIndex;
        other.firstIndex = 0;
    }

    void push_back(T &&newElement) {
        buffer.push_back(move(newElement));
    }
    void push_back(const T& newElement) {
        buffer.push_back(newElement);
    }
    bool empty() const noexcept {
        assert(firstIndex <= buffer.size());
        return firstIndex == buffer.size();
    }
    T& top() noexcept {
        assert(!empty());
        return buffer[firstIndex];
    }
    void pop() noexcept {
        buffer[firstIndex] = T();
        firstIndex++;

        if (firstIndex * 2 >= buffer.size()) {
            /* move elements to front and shrink vector */
            for (size_t index = 0; index < size(); index++) {
                buffer[index] = move(buffer[index + firstIndex]);
            }
            /* resize to smaller size should always succeed */
            buffer.shrinkTo(size());
            firstIndex = 0;
        }
    }
    size_t size() noexcept {
        return buffer.size() - firstIndex;
    }
    /* non-standard */
    void remove(const T &element) noexcept {
        buffer.remove(element);
    }
    void clear() noexcept {
        buffer.clear();
        firstIndex = 0;
    }
};
