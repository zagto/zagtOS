#pragma once

#include <common/common.hpp>

extern "C" void basicLock(volatile size_t &value);
extern "C" void basicUnlock(volatile size_t &value);

class mutex {
private:
    volatile size_t value{0};

public:
    mutex() {}
    mutex(const mutex &) = delete;
    void operator=(mutex &) =delete;

    void lock() {
        basicLock(value);
    }
    void unlock() {
        if (!value) {
            cout << "Attempt to unlock non-locked lock" << endl;
            Panic();
        }
        basicUnlock(value);
    }
    bool isLocked() {
        return value;
    }
};

class scoped_lock {
private:
    mutex *first;
    mutex *second;

public:
    scoped_lock(mutex &_mutex):
        first{&_mutex},
        second{nullptr} {

        first->lock();
    }
    scoped_lock(mutex &a, mutex &b) {
        first = &a;
        second = &b;
        if (first > second) {
            swap(first, second);
        }
        first->lock();
        second->lock();
    }

    scoped_lock(const scoped_lock &other) = delete;
    void operator=(scoped_lock &) =delete;
    ~scoped_lock() {
        if (second) {
            second->unlock();
        }
        first->unlock();
    }
};
