#pragma once

#include <common/common.hpp>

extern "C" void basicLock(volatile size_t &value);
extern "C" bool basicTrylock(volatile size_t &value);
extern "C" void basicUnlock(volatile size_t &value);

class mutex {
private:
    size_t value{0};

public:
    mutex() {}
    mutex(const mutex &) = delete;
    void operator=(const mutex &) =delete;

    void lock();
    bool trylock();
    void unlock();
    bool isLocked() const {
        return value;
    }
};

class SpinLock {
private:
    size_t value{0};

public:
    SpinLock() {}
    SpinLock(const SpinLock &) = delete;
    void operator=(const SpinLock &) =delete;

    void lock();
    bool trylock();
    void unlock();
    bool isLocked() const {
        return value;
    }
};

template<typename LockType>
class scoped_lock {
private:
    LockType *first;
    LockType *second;

public:
    scoped_lock(LockType &lock):
        first{&lock},
        second{nullptr} {

        first->lock();
    }
    scoped_lock(LockType &a, LockType &b) {
        first = &a;
        second = &b;
        if (first > second) {
            swap(first, second);
        }
        first->lock();
        second->lock();
    }
    scoped_lock(const scoped_lock &other) = delete;
    void operator=(scoped_lock &) =delete;
    ~scoped_lock() {
        if (second) {
            second->unlock();
        }
        first->unlock();
    }

    void checkWaiters() {
        // TODO: make this an actual mutex
    }
};
