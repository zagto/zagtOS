#pragma once

#include <common/common.hpp>

extern "C" void basicLock(volatile size_t &value);
extern "C" bool basicTrylock(volatile size_t &value);
extern "C" void basicUnlock(volatile size_t &value);

class mutex {
private:
    volatile size_t value{0};

public:
    mutex() {}
    mutex(const mutex &) = delete;
    void operator=(const mutex &) =delete;

    void lock() {
        basicLock(value);
    }
    bool trylock() {
        return basicTrylock(value);
    }
    void unlock() {
        if (!value) {
            cout << "Attempt to unlock non-locked lock" << endl;
            Panic();
        }
        basicUnlock(value);
    }
    bool isLocked() const {
        return value;
    }
};

class SpinLock {
private:
    size_t value{0};

public:
    SpinLock() {}
    SpinLock(const SpinLock &) = delete;
    void operator=(const SpinLock &) =delete;

    void lock() {
        while (true) {
            size_t expected = 0;
            if (__atomic_compare_exchange_n(&value,
                                            &expected,
                                            1,
                                            false,
                                            __ATOMIC_SEQ_CST,
                                            __ATOMIC_SEQ_CST)) {
                return;
            }
        };
    }
    bool trylock() {
        size_t expected = 0;
        return __atomic_compare_exchange_n(&value,
                                          &expected,
                                          1,
                                          false,
                                          __ATOMIC_SEQ_CST,
                                          __ATOMIC_SEQ_CST);
    }
    void unlock() {
        size_t expected = 1;
        bool ok = __atomic_compare_exchange_n(&value,
                                              &expected,
                                              0,
                                              false,
                                              __ATOMIC_SEQ_CST,
                                              __ATOMIC_SEQ_CST);
        if (!ok) {
            cout << "Attempt to unlock non-locked lock" << endl;
            Panic();
        }
    }
    bool isLocked() const {
        return value;
    }
};

template<typename LockType>
class scoped_lock {
private:
    LockType *first;
    LockType *second;

public:
    scoped_lock(LockType &lock):
        first{&lock},
        second{nullptr} {

        first->lock();
    }
    scoped_lock(LockType &a, LockType &b) {
        first = &a;
        second = &b;
        if (first > second) {
            swap(first, second);
        }
        first->lock();
        second->lock();
    }
    scoped_lock(const scoped_lock &other) = delete;
    void operator=(scoped_lock &) =delete;
    ~scoped_lock() {
        if (second) {
            second->unlock();
        }
        first->unlock();
    }

    void checkWaiters() {
        // TODO: make this an actual mutex
    }
};
