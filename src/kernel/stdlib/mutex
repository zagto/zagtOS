#pragma once

#include <common/common.hpp>

extern "C" void basicLock(volatile size_t &value);
extern "C" bool basicTrylock(volatile size_t &value);
extern "C" void basicUnlock(volatile size_t &value);

class mutex {
private:
    size_t value{0};

public:
    mutex() {}
    mutex(const mutex &) = delete;
    void operator=(const mutex &) =delete;

    void lock();
    bool trylock();
    void unlock();
    bool isLocked() const {
        return value;
    }
};

class SpinLock {
private:
    size_t value{0};

public:
    SpinLock() {}
    SpinLock(const SpinLock &) = delete;
    void operator=(const SpinLock &) =delete;

    void lock();
    bool trylock();
    void unlock();
    bool isLocked() const {
        return value;
    }
};

template<typename LockType>
class scoped_lock {
private:
    LockType *first;
    LockType *second;

public:
    scoped_lock(LockType &lock):
        first{&lock},
        second{nullptr} {

        first->lock();
    }
    scoped_lock(LockType &a, LockType &b) {
        first = &a;
        second = &b;
        if (first > second) {
            swap(first, second);
        }
        first->lock();
        second->lock();
    }
    scoped_lock(const scoped_lock &other) = delete;
    void operator=(scoped_lock &) =delete;
    scoped_lock(scoped_lock &&other) noexcept {
        first = other.first;
        second = other.second;
        other.first = nullptr;
        other.second = nullptr;
    }
    scoped_lock &operator=(scoped_lock &&other) noexcept {
        ~scoped_lock();
        new (this) scoped_lock(other);
        return *this;
    }
    ~scoped_lock() {
        if (second) {
            second->unlock();
        }
        if (first) {
            first->unlock();
        }
    }

    void checkWaiters() {
        // TODO: make this an actual mutex
    }

    /* Do not unlock this lock on destrucion of the scoped_lock. It has to be unlocked manually
     * later. */
    void stick() {
        assert(first);
        first = nullptr;
        second = nullptr;
    }
};
