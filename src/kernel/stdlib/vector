#pragma once

#include <common/common.hpp>
#include <memory/FrameManagement.hpp>
#include <log/Logger.hpp>
#include <lib/Exception.hpp>
#include <memory/DLMallocGlue.hpp>
#include <memory>


template<typename ElementType> class vector {
protected:
    class Iterator {
    private:
        vector<ElementType> &container;

    public:
        size_t position;

        Iterator(vector<ElementType> &container, size_t position):
            container{container},
            position{position} {}
        bool operator!=(const Iterator &other) const {
            return position != other.position || &container != &other.container;
        }
        void operator++() {
            assert(position < container.numElements);
            position++;
        }
        void operator++(int) {
            assert(position < container.numElements);
            position++;
        }
        ElementType &operator*() {
            assert(position < container.numElements);
            return container[position];
        }
        Iterator operator+(size_t add) {
            return Iterator(container, position + add);
        }
    };

    ElementType *_data{nullptr};
    size_t numElements{0};
    size_t numAllocated{0};

    void changeAllocatedSize(size_t newNumAllocated) {
        /* TODO: make sure making it smaller never goes OOM */
        if (newNumAllocated == numAllocated) {
            return;
        }

        KernelVirtualAddress newData = DLMallocGlue.allocate(newNumAllocated * sizeof(ElementType),
                                                             sizeof(ElementType));

        for (size_t index = 0; index < numElements; index++) {
            /* we assume moving never throws */
            new(newData.asPointer<ElementType>() + index) ElementType(move(_data[index]));
            _data[index].~ElementType();
        }
        if (_data != nullptr) {
            DLMallocGlue.free(_data);
        }
        _data = newData.asPointer<ElementType>();
        numAllocated = newNumAllocated;
    }

    void adjustAllocatedSize(size_t newNumElements) {
        if (newNumElements >= numAllocated) {
            changeAllocatedSize((newNumElements + 1) * 3 / 2);
        }
        if (newNumElements < numAllocated >> 1) {
            changeAllocatedSize(newNumElements);
        }
        numElements = newNumElements;
    }

public:
    vector() noexcept {}
    vector(size_t numElements) {
        KernelVirtualAddress result = DLMallocGlue.allocate(numElements * sizeof(ElementType),
                                                            sizeof(ElementType));
        _data = result.asPointer<ElementType>();
        size_t index = 0;
        try {
            for (index = 0; index < numElements; index++) {
                new(&_data[index]) ElementType;
            }
        } catch (...) {
            /* The default constructor of ElementType may throw */
            while (index > 0) {
                _data[index].~ElementType();
                index--;
            }
            DLMallocGlue.free(_data);
        }
        this->numElements = numElements;
        this->numAllocated = numElements;
    }
    vector(size_t numElements, ElementType initialize) {
        KernelVirtualAddress result = DLMallocGlue.allocate(numElements * sizeof(ElementType),
                                                            sizeof(ElementType));
        _data = result.asPointer<ElementType>();
        size_t index = 0;
        try {
            for (index = 0; index < numElements; index++) {
                new(&_data[index]) ElementType(initialize);
            }
        } catch (...) {
            /* The copy constructor of ElementType may throw */
            while (index > 0) {
                _data[index].~ElementType();
                index--;
            }
            DLMallocGlue.free(_data);
        }
        this->numElements = numElements;
        this->numAllocated = numElements;
    }

    /* There is currently no reason to copy vectors in kernel. Implement this if neeeded */
    vector(vector &other) = delete;
    vector(vector &&other) noexcept {
        _data = other._data;
        numElements = other.numElements;
        numAllocated = other.numAllocated;
        other._data = nullptr;
        other.numElements = 0;
        other.numAllocated = 0;
    }
    void operator=(vector &other) = delete;
    void operator=(vector &&other) noexcept {
        clear();
        _data = other._data;
        numElements = other.numElements;
        numAllocated = other.numAllocated;
        other._data = nullptr;
        other.numElements = 0;
        other.numAllocated = 0;
    }
    ~vector() {
        clear();
    }

    ElementType &operator[](size_t index) noexcept {
        assert(index < numElements);
        return _data[index];
    }

    const ElementType &operator[](size_t index) const noexcept {
        assert(index < numElements);
        return _data[index];
    }

    size_t size() const noexcept {
        return numElements;
    }

    void push_back(ElementType &&element) {
        adjustAllocatedSize(numElements + 1);
        /* assume move constructor does not throw */
        new (&_data[numElements - 1]) ElementType(move(element));
    }
    void push_back(const ElementType &element) {
        adjustAllocatedSize(numElements + 1);
        try {
            new (&_data[numElements - 1]) ElementType(element);
        } catch (...) {
            /* make vector smaller again in case of copy constructor failure */
            numElements--;
            throw;
        }
    }

    void insert(ElementType element, size_t index) {
        assert(index <= numElements);

        adjustAllocatedSize(numElements + 1);

        for (size_t moveIndex = numElements - 1; moveIndex > index; moveIndex--) {
            new (&_data[moveIndex]) ElementType(move(_data[moveIndex - 1]));
            _data[moveIndex - 1].~ElementType();
        }

        new (&_data[index]) ElementType(move(element));
    }

    Iterator erase(Iterator first, Iterator last) noexcept {
        size_t numRemove = last.position - first.position;

        numElements -= numRemove;
        for (size_t removeIndex = first.position; removeIndex < last.position; removeIndex++) {
            _data[removeIndex].~ElementType();
        }
        for (size_t moveIndex = first.position; moveIndex < numElements; moveIndex++) {
            new(&_data[moveIndex]) ElementType(move(_data[moveIndex + numRemove]));
            _data[moveIndex + numRemove].~ElementType();
        }

        try {
            adjustAllocatedSize(numElements);
        } catch (...) {
            /* ignore exceptions of adjustAllocatedSize - even if it failed we have removed the
             * element */
        }

        return Iterator(*this, first.position);
    }

    Iterator erase(Iterator where) noexcept {
        return erase(where, where + 1);
    }

    void remove(const ElementType &element) noexcept {
        size_t index;
        for (index = 0; index < numElements; index++) {
            if (_data[index] == element) {
                break;
            }
        }

        if (index == numElements) {
            cout << "Tried to remove Element that is not in vector" << endl;
            Panic();
        }

        erase(begin() + index);
    }

    void resize(size_t newSize) {
        if (newSize <= numElements) {
            while (newSize < numElements) {
                numElements--;
                _data[numElements].~ElementType();
            }

            try {
                adjustAllocatedSize(numElements);
            } catch (...) {
                /* ignore exceptions of adjustAllocatedSize - even if it failed we have removed the
                 * elements */
            }
        } else {
            /* newSize is bigger */
            size_t oldSize = numElements;
            size_t filledSize = numElements;
            adjustAllocatedSize(newSize);
            try {
                while (filledSize < numElements) {
                    new (&_data[filledSize]) ElementType;
                    filledSize++;
                }
            } catch (...) {
                while (filledSize > oldSize) {
                    filledSize--;
                    _data[filledSize].~ElementType();
                }
                numElements = oldSize;
                throw;
            }
        }
    }

    /* version of size that only allows shrinking or leaving the size the same and always
     * succeeds */
    void shrinkTo(size_t newSize) noexcept {
        assert(newSize <= numElements);
        resize(newSize);
    }


    void clear() noexcept {
        for (size_t index = 0; index < numElements; index++) {
            _data[index].~ElementType();
        }
        if (_data != nullptr) {
            DLMallocGlue.free(_data);
        }
    }

    ElementType *data() const noexcept {
        return _data;
    }

    Iterator begin() noexcept {
        return Iterator(*this, 0);
    }

    Iterator end() noexcept {
        return Iterator(*this, numElements);
    }
};

template<typename ElementType> size_t distance(typename vector<ElementType>::Iterator first,
                                             typename vector<ElementType>::Iterator last) noexcept {
    assert(last.position >= first.position);
    return last.position - first.position;
}
