#pragma once

#include <common/common.hpp>
#include <memory/FrameManagement.hpp>
#include <log/Logger.hpp>
#include <lib/Status.hpp>
#include <memory/DLMallocGlue.hpp>
#include <memory>


template<typename ElementType> class vector {
protected:
    class Iterator {
    private:
        vector<ElementType> &container;

    public:
        size_t position;

        Iterator(vector<ElementType> &container, size_t position):
            container{container},
            position{position} {}
        bool operator!=(const Iterator &other) const {
            return position != other.position || &container != &other.container;
        }
        void operator++() {
            assert(position < container.numElements);
            position++;
        }
        void operator++(int) {
            assert(position < container.numElements);
            position++;
        }
        ElementType &operator*() {
            assert(position < container.numElements);
            return container[position];
        }
        Iterator operator+(size_t add) {
            return Iterator(container, position + add);
        }
    };

    ElementType *_data{nullptr};
    size_t numElements{0};
    size_t numAllocated{0};

    Status changeAllocatedSize(size_t newNumAllocated) {
        /* TODO: make sure making it smaller never goes OOM */
        if (newNumAllocated == numAllocated) {
            return Status::OK();
        }

        Result newData = DLMallocGlue.allocate(newNumAllocated * sizeof(ElementType),
                                               sizeof(ElementType));
        if (!newData) {
            return newData.status();
        }

        for (size_t index = 0; index < numElements; index++) {
            new(&newData->asPointer<ElementType>()[index]) ElementType(move(_data[index]));
            _data[index].~ElementType();
        }
        if (_data != nullptr) {
            DLMallocGlue.free(_data);
        }
        _data = newData->asPointer<ElementType>();
        numAllocated = newNumAllocated;

        return Status::OK();
    }

    Status adjustAllocatedSize(size_t newNumElements) {
        Status status = Status::OK();
        if (newNumElements >= numAllocated) {
            status = changeAllocatedSize((newNumElements + 1) * 3 / 2);
        }
        if (newNumElements < numAllocated >> 1) {
            status = changeAllocatedSize(newNumElements);
        }
        if (!status) {
            return status;
        }
        numElements = newNumElements;
        return Status::OK();
    }

public:
    vector() {}
    vector(size_t numElements, Status &status) {
        if (!status) {
            return;
        }
        Result result = DLMallocGlue.allocate(numElements * sizeof(ElementType),
                                               sizeof(ElementType));
        if (!result) {
            status = result.status();
            return;
        }

        _data = result->asPointer<ElementType>();
        for (size_t index = 0; index < numElements; index++) {
            new(&_data[index]) ElementType;
        }
        this->numElements = numElements;
        this->numAllocated = numElements;
    }
    vector(size_t numElements, ElementType initialize, Status &status) {
        if (!status) {
            return;
        }
        Result result = DLMallocGlue.allocate(numElements * sizeof(ElementType),
                                               sizeof(ElementType));
        if (!result) {
            status = result.status();
            return;
        }

        _data = result->asPointer<ElementType>();
        for (size_t index = 0; index < numElements; index++) {
            new(&_data[index]) ElementType(initialize);
        }
        this->numElements = numElements;
    }

    /* There is currently no reason to copy vectors in kernel. Implement this if neeeded */
    vector(vector &other) = delete;
    vector(vector &&other) {
        _data = other._data;
        numElements = other.numElements;
        numAllocated = other.numAllocated;
        other._data = nullptr;
        other.numElements = 0;
        other.numAllocated = 0;
    }
    void operator=(vector &other) = delete;
    void operator=(vector &&other) {
        if (_data) {
            DLMallocGlue.free(_data);
        }
        _data = other._data;
        numElements = other.numElements;
        numAllocated = other.numAllocated;
        other._data = nullptr;
        other.numElements = 0;
        other.numAllocated = 0;
    }
    ~vector() {
        clear();
    }

    ElementType &operator[](size_t index) {
        assert(index < numElements);
        return _data[index];
    }

    const ElementType &operator[](size_t index) const {
        assert(index < numElements);
        return _data[index];
    }

    size_t size() const {
        return numElements;
    }

    Status push_back(ElementType &&element) {
        Status status = adjustAllocatedSize(numElements + 1);
        if (!status) {
            return status;
        }
        new (&_data[numElements - 1]) ElementType(move(element));
        return Status::OK();
    }
    Status push_back(const ElementType &element) {
        Status status = adjustAllocatedSize(numElements + 1);
        if (!status) {
            return status;
        }
        new (&_data[numElements - 1]) ElementType(element);
        return Status::OK();
    }

    Status insert(ElementType element, size_t index) {
        assert(index <= numElements);

        Status status = adjustAllocatedSize(numElements + 1);
        if (!status) {
            return status;
        }

        for (size_t moveIndex = numElements - 1; moveIndex > index; moveIndex--) {
            new (&_data[moveIndex]) ElementType(move(_data[moveIndex - 1]));
            _data[moveIndex - 1].~ElementType();
        }

        new (&_data[index]) ElementType(move(element));
        return Status::OK();
    }

    Iterator erase(Iterator first, Iterator last) {
        size_t numRemove = last.position - first.position;

        numElements -= numRemove;
        for (size_t removeIndex = first.position; removeIndex < last.position; removeIndex++) {
            _data[removeIndex].~ElementType();
        }
        for (size_t moveIndex = first.position; moveIndex < numElements; moveIndex++) {
            new(&_data[moveIndex]) ElementType(move(_data[moveIndex + numRemove]));
            _data[moveIndex + numRemove].~ElementType();
        }
        /* ignore status of adjustAllocatedSize - even if it failed we have removed the element */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
        Status ignored = adjustAllocatedSize(numElements);
#pragma GCC diagnostic pop

        return Iterator(*this, first.position);
    }

    Iterator erase(Iterator where) {
        return erase(where, where + 1);
    }

    void remove(const ElementType &element) {
        size_t index;
        for (index = 0; index < numElements; index++) {
            if (_data[index] == element) {
                break;
            }
        }

        if (index == numElements) {
            cout << "Tried to remove Element that is not in vector" << endl;
            Panic();
        }

        erase(begin() + index);
    }

    Status resize(size_t newSize) {
        while (newSize < numElements) {
            numElements--;
            _data[numElements].~ElementType();
        }
        size_t filledSize = numElements;
        Status status = adjustAllocatedSize(newSize);
        while (filledSize < numElements) {
            new (&_data[filledSize]) ElementType;
            filledSize++;
        }
        if (newSize == numElements) {
            /* ignore status of adjustAllocatedSize for shrinks - even if it failed to shrink the
             * allocated memory we have removed the element */
            return Status::OK();
        }
        return status;
    }

    /* version of size that only allows shrinking or leaving the size the same and always
     * succeeds */
    void shrinkTo(size_t newSize) {
        assert(newSize <= numElements);
        Status success = resize(newSize);
        assert(success);
    }


    void clear() {
        for (size_t index = 0; index < numElements; index++) {
            _data[index].~ElementType();
        }
        if (_data != nullptr) {
            DLMallocGlue.free(_data);
        }
    }

    ElementType *data() const {
        return _data;
    }

    Iterator begin() {
        return Iterator(*this, 0);
    }

    Iterator end() {
        return Iterator(*this, numElements);
    }
};
