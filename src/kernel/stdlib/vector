#pragma once

#include <common/common.hpp>
#include <memory/FrameManagement.hpp>
#include <log/Logger.hpp>
#include <lib/Status.hpp>
#include <memory>

template<typename ElementType> class vector {
protected:
    class Iterator {
    private:
        vector<ElementType> &container;

    public:
        size_t position;

        Iterator(vector<ElementType> &container, size_t position):
            container{container},
            position{position} {}
        bool operator!=(const Iterator &other) const {
            return position != other.position || &container != &other.container;
        }
        void operator++() {
            assert(position < container.numElements);
            position++;
        }
        void operator++(int) {
            assert(position < container.numElements);
            position++;
        }
        ElementType &operator*() {
            assert(position < container.numElements);
            return container[position];
        }
        Iterator operator+(size_t add) {
            return Iterator(container, position + add);
        }
    };

    ElementType *_data{nullptr};
    size_t numElements{0};
    size_t numAllocated{0};

    Status changeAllocatedSize(size_t newNumAllocated) {
        /* TODO: make sure making it smaller never goes OOM */
        if (newNumAllocated == numAllocated) {
            return Status::OK();
        }

        Result<ElementType *> newData = make_raw_array<ElementType>(newNumAllocated);
        if (!newData) {
            return newData.status();
        }

        size_t elementsToMove = min(numAllocated, newNumAllocated);
        if (_data != nullptr) {
            for (size_t index = 0; index < elementsToMove; index++) {
                (*newData)[index] = move(_data[index]);
            }
            delete[] _data;
        }
        _data = *newData;
        numAllocated = newNumAllocated;

        return Status::OK();
    }
    Status adjustAllocatedSize(size_t newNumElements) {
        Status status = Status::OK();
        if (newNumElements >= numAllocated) {
            status = changeAllocatedSize((newNumElements + 1) * 3 / 2);
        }
        if (newNumElements < numAllocated >> 1) {
            status = changeAllocatedSize(newNumElements);
        }
        if (!status) {
            return status;
        }
        numElements = newNumElements;
        return Status::OK();
    }

public:
    vector() {}
    vector(size_t numElements, Status &status):
           _data{nullptr},
           numElements{numElements},
           numAllocated{numElements}  {

        Result<ElementType *> result = make_raw_array<ElementType>(numElements);
        if (result) {
            _data = *result;
        } else {
            status = result.status();
        }
    }
    vector(size_t numElements, ElementType fill, Status &status):
           vector(numElements, status) {
        if (status) {
            for (size_t index = 0; index < numElements; index++) {
                _data[index] = move(fill);
            }
        }
    }
    /* There is currently no reason to copy vectors in kernel. Implement this if neeeded */
    vector(vector &other) = delete;
    vector(vector &&other) {
        _data = other._data;
        numElements = other.numElements;
        numAllocated = other.numAllocated;
        other._data = nullptr;
        other.numElements = 0;
        other.numAllocated = 0;
    }
    void operator=(vector &other) = delete;
    void operator=(vector &&other) {
        if (_data) {
            delete[] _data;
        }
        _data = other._data;
        numElements = other.numElements;
        numAllocated = other.numAllocated;
        other._data = nullptr;
        other.numElements = 0;
        other.numAllocated = 0;
    }
    ~vector() {
        clear();
    }

    ElementType &operator[](size_t index) {
        assert(index < numElements);
        return _data[index];
    }

    const ElementType &operator[](size_t index) const {
        assert(index < numElements);
        return _data[index];
    }

    size_t size() const {
        return numElements;
    }

    Status push_back(ElementType &&element) {
        Status status = adjustAllocatedSize(numElements + 1);
        if (!status) {
            return status;
        }
        _data[numElements - 1] = move(element);
        return Status::OK();
    }
    Status push_back(const ElementType &element) {
        Status status = adjustAllocatedSize(numElements + 1);
        if (!status) {
            return status;
        }
        _data[numElements - 1] = element;
        return Status::OK();
    }

    Status insert(ElementType element, size_t index) {
        assert(index <= numElements);

        Status status = adjustAllocatedSize(numElements + 1);
        if (!status) {
            return status;
        }

        for (size_t moveIndex = numElements - 1; moveIndex > index; moveIndex--) {
            _data[moveIndex] = move(_data[moveIndex - 1]);
        }

        _data[index] = move(element);
        return Status::OK();
    }

    Iterator erase(Iterator first, Iterator last) {
        size_t numRemove = last.position - first.position;

        numElements -= numRemove;
        for (size_t moveIndex = first.position; moveIndex < numElements; moveIndex++) {
            _data[moveIndex] = move(_data[moveIndex + numRemove]);
        }
        /* ignore status of adjustAllocatedSize - even if it failed we have removed the element */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
        Status ignored = adjustAllocatedSize(numElements);
#pragma GCC diagnostic pop

        return Iterator(*this, first.position);
    }

    Iterator erase(Iterator where) {
        return erase(where, where + 1);
    }

    void remove(const ElementType &element) {
        size_t index;
        for (index = 0; index < numElements; index++) {
            if (_data[index] == element) {
                break;
            }
        }

        if (index == numElements) {
            cout << "Tried to remove Element that is not in vector" << endl;
            Panic();
        }

        erase(begin() + index);
    }

    Status resize(size_t newSize) {
        while (newSize < numElements) {
            numElements--;
            _data[numElements] = ElementType();
        }
        Status status = adjustAllocatedSize(newSize);
        if (newSize == numElements) {
            /* ignore status of adjustAllocatedSize for shrinks - even if it failed to shrink the
             * allocated memory we have removed the element */
            return Status::OK();
        }
        return status;
    }

    /* version of size that only allows shrinking or leaving the size the same and always
     * succeeds */
    void shrinkTo(size_t newSize) {
        assert(newSize <= numElements);
        Status success = resize(newSize);
        assert(success);
    }


    void clear() {
        if (_data != nullptr) {
            delete[] _data;
        }
    }

    ElementType *data() const {
        return _data;
    }

    Iterator begin() {
        return Iterator(*this, 0);
    }

    Iterator end() {
        return Iterator(*this, numElements);
    }
};
