#pragma once

#include <common/common.hpp>
#include <memory/Memory.hpp>
#include <log/Logger.hpp>
#include <memory>

template<typename ElementType> class vector {
protected:
    class Iterator {
    private:
        vector<ElementType> &container;
        size_t position;
    public:
        Iterator(vector<ElementType> &container, size_t position):
            container{container},
            position{position} {}
        bool operator!=(const Iterator &other) const {
            return position != other.position || &container != &other.container;
        }
        void operator++() {
            assert(position < container.numElements);
            position++;
        }
        ElementType &operator*() {
            assert(position < container.numElements);
            return container[position];
        }
    };

    ElementType *_data{nullptr};
    size_t numElements{0};
    size_t numAllocated{0};

    void changeAllocatedSize(size_t newNumAllocated) {
        if (newNumAllocated == numAllocated) {
            return;
        }

        ElementType *newData = new ElementType[newNumAllocated];
        size_t elementsToMove = min(numAllocated, newNumAllocated);
        if (_data != nullptr) {
            for (size_t index = 0; index < elementsToMove; index++) {
                newData[index] = move(_data[index]);
            }
            delete[] _data;
        }
        _data = newData;
        numAllocated = newNumAllocated;
    }
    void adjustAllocatedSize() {
        if (numElements >= numAllocated) {
            changeAllocatedSize((numElements + 1) * 3 / 2);
        }
        if (numElements < numAllocated >> 1) {
            changeAllocatedSize(numElements);
        }
    }

public:
    vector() {}
    vector(size_t numElements):
           _data{new ElementType[numElements]},
           numElements{numElements},
           numAllocated{numElements}  {
    }
    /* There is currently no reason to copy vectors in kernel. Implement this if neeeded */
    vector(vector &other) = delete;
    vector(vector &&other) {
        _data = other._data;
        numElements = other.numElements;
        numAllocated = other.numAllocated;
        other._data = nullptr;
        other.numElements = 0;
        other.numAllocated = 0;
    }
    void operator=(vector &other) = delete;
    void operator=(vector &&other) {
        if (_data) {
            delete[] _data;
        }
        _data = other._data;
        numElements = other.numElements;
        numAllocated = other.numAllocated;
        other._data = nullptr;
        other.numElements = 0;
        other.numAllocated = 0;
    }
    ~vector() {
        if (_data != nullptr) {
            delete[] _data;
        }
    }

    ElementType &operator[](size_t index) {
        assert(index < numElements);
        return _data[index];
    }

    const ElementType &operator[](size_t index) const {
        assert(index < numElements);
        return _data[index];
    }

    size_t size() const {
        return numElements;
    }

    void push_back(ElementType &&element) {
        numElements++;
        adjustAllocatedSize();
        _data[numElements - 1] = move(element);
    }
    void push_back(const ElementType &element) {
        numElements++;
        adjustAllocatedSize();
        _data[numElements - 1] = element;
    }

    void insert(ElementType element, size_t index) {
        assert(index <= numElements);
        numElements++;
        adjustAllocatedSize();

        for (size_t moveIndex = numElements - 1; moveIndex > index; moveIndex--) {
            _data[moveIndex] = move(_data[moveIndex - 1]);
        }

        _data[index] = element;
    }

    void remove(ElementType element) {
        size_t index;
        for (index = 0; index < numElements; index++) {
            if (_data[index] == element) {
                break;
            }
        }

        if (index == numElements) {
            cout << "Tried to remove Element that is not in vector" << endl;
            Panic();
        }

        numElements--;
        for (size_t moveIndex = index; moveIndex < numElements; moveIndex++) {
            _data[moveIndex] = move(_data[moveIndex + 1]);
        }
        adjustAllocatedSize();
    }

    void reserve(size_t amount) {
        assert(amount >= numElements);
        if (amount != numAllocated) {
            changeAllocatedSize(amount);
        }
    }

    ElementType *data() const {
        return _data;
    }

    Iterator begin() {
        return Iterator(*this, 0);
    }
    Iterator end() {
        return Iterator(*this, numElements);
    }
};
